local UserInputService = game:GetService("UserInputService")
local camera = workspace.CurrentCamera

local Autoplayer = {
    noteY = 3879,
    sliderY = 3878,
    laneDistanceThreshold = 25,
    distanceLowerBound = 0.2,
    distanceUpperBound = 0.8,
    sliderDebounce = 0.06,
    random = Random.new(),
    pressedLanes = {},
    heldLanes = {},
    currentLanePositionsIndex = nil,
    lanePositions = {
        {
            Vector3.new(-309.00, 387.70, -181.09),
            Vector3.new(-306.87, 387.70, -178.56),
            Vector3.new(-304.53, 387.70, -176.21),
            Vector3.new(-301.99, 387.70, -174.08)
        },

        {
            Vector3.new(-301.99, 387.70, -235.64),
            Vector3.new(-304.53, 387.70, -233.51),
            Vector3.new(-306.87, 387.70, -231.16),
            Vector3.new(-309.00, 387.70, -228.60)
        },

        {
            Vector3.new(-247.44, 387.70, -228.63),
            Vector3.new(-249.57, 387.70, -231.16),
            Vector3.new(-251.92, 387.70, -233.51),
            Vector3.new(-254.46, 387.70, -235.64)
        },

        {
            Vector3.new(-254.46, 387.70, -174.08),
            Vector3.new(-251.92, 387.70, -176.21),
            Vector3.new(-249.57, 387.70, -178.56),
            Vector3.new(-247.44, 387.70, -181.09)
        }
    }
}

local function UpdateLanePositions()
    local nearestDistance = Autoplayer.laneDistanceThreshold
    local nearestGroupIndex

    for groupIndex, groupPositions in ipairs(Autoplayer.lanePositions) do
        local distance = (groupPositions[1] - camera.CFrame.Position).Magnitude

        if distance < nearestDistance then
            nearestDistance = distance
            nearestGroupIndex = groupIndex
        end
    end

    Autoplayer.currentLanePositionsIndex = nearestGroupIndex
end

local function GetNearestLane(position)
    UpdateLanePositions()

    local nearestDistance = Autoplayer.laneDistanceThreshold
    local nearestLane

    for laneIndex, lanePosition in ipairs(Autoplayer.lanePositions[Autoplayer.currentLanePositionsIndex]) do
        local distance = (lanePosition - position).Magnitude

        if distance < nearestDistance then
            nearestDistance = distance
            nearestLane = {laneIndex, lanePosition}
        end
    end

    if not nearestLane then 
        return
    end

    return nearestLane[1], nearestLane[2]
end

local function OnTouchInput(input)
    if input.UserInputType == Enum.UserInputType.Touch then
        local touchPosition = input.Position
        local touchRay = camera:ScreenPointToRay(touchPosition.X, touchPosition.Y)

        -- Example: Check if touch hits any note or slider
        for _, instance in ipairs(workspace:GetDescendants()) do
            if instance.ClassName == "CylinderHandleAdornment" then
                local noteLane, lanePosition = GetNearestLane(touchRay.Origin + touchRay.Direction * 100) -- Adjust distance as needed

                if noteLane then
                    local randomDistance = Autoplayer.random:NextNumber(Autoplayer.distanceLowerBound, Autoplayer.distanceUpperBound)
                    local distance = (instance.Position - lanePosition).Magnitude

                    if distance <= randomDistance then
                        if instance.Transparency == 0 and math.floor(instance.Position.Y * 10) == Autoplayer.noteY then
                            if not Autoplayer.pressedLanes[noteLane] then
                                Autoplayer.pressedLanes[noteLane] = true

                                -- Simulate key press action
                                -- Example: VirtualInputManager:SendKeyEvent(true, keys[noteLane], false, game)
                                print("Note pressed:", noteLane)

                                task.wait(Autoplayer.random:NextNumber(Autoplayer.delayLowerBound, Autoplayer.delayUpperBound))

                                -- Simulate key release action
                                -- Example: VirtualInputManager:SendKeyEvent(false, keys[noteLane], false, game)
                                print("Note released:", noteLane)

                                Autoplayer.pressedLanes[noteLane] = false
                            end
                        elseif instance.Transparency < 1 and instance.Height > 0.2 and math.floor(instance.Position.Y * 10) == Autoplayer.sliderY then
                            local sliderDistance = (instance.Position - lanePosition).Magnitude

                            if sliderDistance <= randomDistance then
                                if not Autoplayer.heldLanes[noteLane] then
                                    Autoplayer.heldLanes[noteLane] = true

                                    -- Simulate key press action for slider hold
                                    -- Example: VirtualInputManager:SendKeyEvent(true, keys[noteLane], false, game)
                                    print("Slider pressed:", noteLane)

                                    repeat
                                        task.wait() -- Adjust as needed for slider hold logic
                                    until (instance.Position - lanePosition).Magnitude > randomDistance

                                    -- Simulate key release action after slider hold
                                    -- Example: VirtualInputManager:SendKeyEvent(false, keys[noteLane], false, game)
                                    print("Slider released:", noteLane)

                                    task.wait(Autoplayer.sliderDebounce)

                                    Autoplayer.heldLanes[noteLane] = false
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

UserInputService.InputBegan:Connect(OnTouchInput)

-- Additional touch handling and UI adjustments as needed
