--// variables
loadstring(game:HttpGet("https://raw.githubusercontent.com/3345-c-a-t-s-u-s/NEVERLOSE-UI-Nightly/main/source.lua"))():Notification():Notify("success", "Success!", "Successfully loaded autoplayer.",5)

local player = game:GetService("Players").LocalPlayer;

local accuracy_bounds = {
    Perfect = -0, 
    Great = -100,
    Okay = -100
};

local accuracy_names = {"Perfect", "Great", "Okay"};

local accuracy = shared.accuracy or "Perfect"; -- Perfect, Great, Okay, Random
local note_time_target = accuracy_bounds[accuracy];

local track_system;

--// UI elements
local function createDropdownMenu(parent, dropdownName, options, defaultOption, callback)
    local dropdown = Instance.new("Frame")
    dropdown.Name = "Dropdown"
    dropdown.Parent = parent
    dropdown.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    dropdown.Size = UDim2.new(0.5, 0, 0, 30)
    dropdown.Position = UDim2.new(0.25, 0, 0.5, 0)
    dropdown.ClipsDescendants = true

    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 5)
    uiCorner.Parent = dropdown

    local label = Instance.new("TextLabel")
    label.Name = "Label"
    label.Parent = dropdown
    label.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(1, -20, 1, 0)
    label.Font = Enum.Font.SourceSans
    label.Text = dropdownName
    label.TextColor3 = Color3.fromRGB(0, 0, 0)
    label.TextScaled = true
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Position = UDim2.new(0, 10, 0, 0)

    local button = Instance.new("TextButton")
    button.Name = "Button"
    button.Parent = dropdown
    button.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    button.BackgroundTransparency = 1
    button.Size = UDim2.new(1, 0, 1, 0)
    button.Font = Enum.Font.SourceSans
    button.Text = "â–¼"
    button.TextColor3 = Color3.fromRGB(0, 0, 0)
    button.TextScaled = true
    button.TextXAlignment = Enum.TextXAlignment.Right

    local itemsFrame = Instance.new("Frame")
    itemsFrame.Name = "ItemsFrame"
    itemsFrame.Parent = dropdown
    itemsFrame.BackgroundColor3 = Color3.fromRGB(240, 240, 240)
    itemsFrame.Size = UDim2.new(1, 0, 0, #options * 30)
    itemsFrame.Position = UDim2.new(0, 0, 1, 0)
    itemsFrame.Visible = false

    local uiListLayout = Instance.new("UIListLayout")
    uiListLayout.Parent = itemsFrame
    uiListLayout.SortOrder = Enum.SortOrder.LayoutOrder

    for _, option in ipairs(options) do
        local itemButton = Instance.new("TextButton")
        itemButton.Name = option
        itemButton.Parent = itemsFrame
        itemButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        itemButton.Size = UDim2.new(1, 0, 0, 30)
        itemButton.Font = Enum.Font.SourceSans
        itemButton.Text = option
        itemButton.TextColor3 = Color3.fromRGB(0, 0, 0)
        itemButton.TextScaled = true
        itemButton.MouseButton1Click:Connect(function()
            label.Text = option
            itemsFrame.Visible = false
            dropdown:TweenSize(UDim2.new(0.5, 0, 0, 30), "Out", "Quad", 0.3, true)
            callback(option)
        end)
    end

    button.MouseButton1Click:Connect(function()
        itemsFrame.Visible = not itemsFrame.Visible
        if itemsFrame.Visible then
            dropdown:TweenSize(UDim2.new(0.5, 0, 0, #options * 30 + 30), "Out", "Quad", 0.3, true)
        else
            dropdown:TweenSize(UDim2.new(0.5, 0, 0, 30), "Out", "Quad", 0.3, true)
        end
    end)

    -- Set the default option
    label.Text = defaultOption
end

-- Example usage
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "DropdownScreenGui"
screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

createDropdownMenu(screenGui, "Select Accuracy", {"Perfect", "Great", "Okay"}, "Perfect", function(selected)
    accuracy = selected
    note_time_target = accuracy_bounds[accuracy]
    print("Selected accuracy:", accuracy)
end)

--// functions 

local function get_track_action_functions(track_system)
    local press_track, release_track; 

    for index, track_function in next, track_system do 
        if type(track_function) == "function" then 
            local constants = getconstants(track_function);

            if table.find(constants, "press") then 
                press_track = track_function;

                if release_track then 
                    break; 
                end;
            elseif table.find(constants, "release") then 
                release_track = track_function;

                if press_track then 
                    break; 
                end;
            end;
        end;
    end;

    return press_track, release_track;
end;

local function get_local_track_system(session)
    local local_slot_index = getupvalue(session.set_local_game_slot, 1);

    for index, session_function in next, session do 
        if type(session_function) == "function" then 
            local object = getupvalues(session_function)[1];

            if type(object) == "table" and rawget(object, "count") and object:count() <= 4 then 
                return object:get(local_slot_index);
            end;
        end;
    end;
end;

--// get tracksystem 

for index, module in next, getloadedmodules() do 
    local module_value = require(module);

    if type(module_value) == "table" then 
        local new_function = rawget(module_value, "new");

        if new_function then 
            local first_upvalue = getupvalues(new_function)[1];

            if type(first_upvalue) == "table" and rawget(first_upvalue, "twister") then 
                track_system = module_value;

                break;
            end;
        end;
    end;
end;

--// main autoplayer 

local old_track_system_new = track_system.new;
track_system.new = function(...)
    local track_functions = old_track_system_new(...);
    local arguments = {...};

    if arguments[2]._players._slots:get(arguments[3])._name == player.Name then -- make sure its only autoplaying your notes if in multiplayer
        for index, track_function in next, track_functions do 
            local upvalues = getupvalues(track_function);

            if type(upvalues[1]) == "table" and rawget(upvalues[1], "profilebegin") then 
                local notes_table = upvalues[2];

                track_functions[index] = function(self, slot, session)
                    local local_track_system = get_local_track_system(session);
                    local press_track, release_track = get_track_action_functions(local_track_system);

                    local test_press_name = getconstant(press_track, 10);
                    local test_release_name = getconstant(release_track, 6);

                    if accuracy == "Random" then 
                        note_time_target = accuracy_bounds[accuracy_names[math.random(1, 3)]];
                    end;

                    for note_index = 1, notes_table:count() do 
                        local note = notes_table:get(note_index);

                        if note then 
                            local test_press, test_release = note[test_press_name], note[test_release_name];

                            local note_track_index = note:get_track_index(note_index);
                            local pressed, press_result, press_delay = test_press(note);

                            if pressed and press_delay >= note_time_target then
                                  press_track(local_track_system, session, note_track_index);

                                   session:debug_any_press();

                                   if rawget(note, "get_time_to_end") then -- if its not a long note then release right after

                                           release_track(local_track_system, session, note_track_index);

                                    end;
                            end;

                            if test_release then 
                                local released, release_result, release_delay = test_release(note);

                                if released and release_delay >= note_time_target then 

                                        release_track(local_track_system, session, note_track_index);

                                end;
                            end;
                        end;
                    end;

                    return track_function(self, slot, session);
                end;
            end;
        end;
    end;

    return track_functions;
end;
